<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ Primer 第三章 字符串、向量和数组</title>
      <link href="/2022/06/22/c-primer-3/"/>
      <url>/2022/06/22/c-primer-3/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-命名空间的-using-声明"><a href="#3-1-命名空间的-using-声明" class="headerlink" title="3.1 命名空间的 using 声明"></a>3.1 命名空间的 using 声明</h2><p>&emsp;<code>using</code> 声明可以更简单地使用命名空间中的成员。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token comment">// 单独使用 </span><span class="token comment">// using std::cin; </span><span class="token comment">// using std::cout;</span><span class="token comment">// using std::endl;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    cin <span class="token operator">>></span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="头文件不应包含-using-声明"><a href="#头文件不应包含-using-声明" class="headerlink" title="头文件不应包含 using 声明"></a>头文件不应包含 using 声明</h3><p>&emsp;因为头文件的内容会在预处理阶段拷贝到其他文件中，如果头文件中有 <code>using</code> 声明，那么使用该头文件的所有文件都有这个声明，由于不经意间拷贝过去，有时候就会导致名称冲突。</p><h2 id="3-2-标准库类型-string"><a href="#3-2-标准库类型-string" class="headerlink" title="3.2 标准库类型 string"></a>3.2 标准库类型 string</h2><p>&emsp;<code>string</code> 表示<strong>可变长的字符序列</strong>，使用 <code>string</code> 类型必须首先包含 <code>string</code> 头文件。</p><h3 id="3-2-1-定义和初始化-string-对象"><a href="#3-2-1-定义和初始化-string-对象" class="headerlink" title="3.2.1 定义和初始化 string 对象"></a>3.2.1 定义和初始化 string 对象</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string s1<span class="token punctuation">;</span> <span class="token comment">// 默认初始化 s1 是一个空字符串</span>string <span class="token function">s2</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s2 是 s1 的副本</span>string s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span> <span class="token comment">// 等价于 string s2(s1)</span>string <span class="token function">s3</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//s3 是字面值 "value" 的副本 除了最后的'\0'都进行拷贝</span>string s3 <span class="token operator">=</span> <span class="token string">"value"</span><span class="token punctuation">;</span> <span class="token comment">//等价于 string s3("value")</span>string <span class="token function">s4</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token char">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接初始化 为连续的 n 个字符 c 组成的串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-string-对象上的操作"><a href="#3-2-2-string-对象上的操作" class="headerlink" title="3.2.2 string 对象上的操作"></a>3.2.2 string 对象上的操作</h3><p>&emsp;一个类规定初始化的方式后，还要定义对象上所能进行的操作。</p><h4 id="读写-string-对象"><a href="#读写-string-对象" class="headerlink" title="读写 string 对象"></a>读写 string 对象</h4><p>&emsp;在执行读取操作时，<code>string</code> 对象会自动忽略开头的空白（制表符、空格、换行符），从第一个非空字符读起，直到遇见下一个空白。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    string s<span class="token punctuation">;</span>    cin <span class="token operator">>></span> s<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="读取未知数量的-string-对象"><a href="#读取未知数量的-string-对象" class="headerlink" title="读取未知数量的 string 对象"></a>读取未知数量的 string 对象</h5><p>&emsp;每一次都会将中间的空白忽略掉，直到遇到 EOF 或者非法输入。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    string word<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> word<span class="token punctuation">)</span>        <span class="token comment">// 输入: "     123     456     789     "</span>        <span class="token comment">// 输出:</span>        <span class="token comment">// 123 </span>        <span class="token comment">// 456 </span>        <span class="token comment">// 789 </span>        cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="使用-getline-读取一整行"><a href="#使用-getline-读取一整行" class="headerlink" title="使用 getline 读取一整行"></a>使用 getline 读取一整行</h5><p>&emsp;<code>getline</code> 函数的参数是一个输入流和一个 <code>string</code> 对象，函数会从给定的输入流中读取内容，直到遇到<strong>换行符</strong>为止，实际上会把换行符也读取，然后将除了换行符以外的内容存入到 <code>string</code> 对象中。如果只有换行符，那么所得的结果就是一个空字符串。返回流参数，因此也能够用在 <code>while</code> 循环的条件判断中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    string line<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// line 中不包含换行符</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="string-的-empty-和-size-操作"><a href="#string-的-empty-和-size-操作" class="headerlink" title="string 的 empty 和 size 操作"></a>string 的 empty 和 size 操作</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    string line<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>line<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 返回布尔值</span>            cout <span class="token operator">&lt;&lt;</span> line <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">)</span> <span class="token comment">// 返回字符的个数</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"too long"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="string-size-type-类型"><a href="#string-size-type-类型" class="headerlink" title="string::size_type 类型"></a>string::size_type 类型</h5><p>&emsp;实际上，<code>size</code> 函数返回的是一个 <code>string::size_type</code> 类型的<strong>无符号数</strong>。它定义在 <code>string</code> 中，用来体现<strong>标准库类型与机器无关的特性</strong>。要注意的是，返回的是一个无符号数，如果表达式中混带了带符号数和该数，那么有可能产生意想不到的错误。一般使用类型说明符 <code>auto</code> 和类型指示符 <code>decltype</code> 来推断变量的类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> len <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> len <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="比较-string-对象"><a href="#比较-string-对象" class="headerlink" title="比较 string 对象"></a>比较 string 对象</h4><p>&emsp;<code>string</code> 对象的比较遵循<strong>字典序</strong>，先比较字符(z &gt; a)，再比较长短(aa &gt; a)，对大小写敏感(A &gt; a)。</p><h4 id="两个-string-对象相加"><a href="#两个-string-对象相加" class="headerlink" title="两个 string 对象相加"></a>两个 string 对象相加</h4><p>&emsp;两个 <code>string</code> 对象相加得到一个<strong>新的</strong> <code>string</code> 对象，由两个 <code>string</code> 对象连接而成，同时还支持 <code>+=</code> 复合运算符。</p><h5 id="字面值和-string-对象相加"><a href="#字面值和-string-对象相加" class="headerlink" title="字面值和 string 对象相加"></a>字面值和 string 对象相加</h5><p>&emsp;当把 <code>string</code> 对象和字符字面值和字符串字面值混合在一条语句中使用时，必须确保每个 <code>+</code> 两侧的运算对象至少有一个是 <code>string</code> 对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string s1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> s2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>string s3 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> s2<span class="token punctuation">;</span> string s4 <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> s2<span class="token punctuation">;</span> <span class="token comment">// 错误 两个字符串字面值相加</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-3-处理-string-对象中的字符"><a href="#3-2-3-处理-string-对象中的字符" class="headerlink" title="3.2.3 处理 string 对象中的字符"></a>3.2.3 处理 string 对象中的字符</h3><p>&emsp;在 <code>cctype</code> 头文件中定义了一组标准库函数。</p><ul><li><code>isalpha(c)</code>: 当 c 是字母时返回 <code>true</code></li><li><code>isdigit(c)</code>: 当 c 是数字时返回 <code>true</code></li><li><code>ispunct(c)</code>: 当 c 是标点符号时返回 <code>true</code></li><li><code>islower(c)</code>: 当 c 是小写字母时返回 <code>true</code></li><li><code>isupper(c)</code>: 当 c 是大写字母时返回 <code>true</code></li><li><code>tolower(c)</code>: 当 c 是大写字母时返回其小写字母，否则原样返回。</li><li><code>toupper(c)</code>: 当 c 是小写字母时返回其大写字母，否则原样返回。<blockquote><p>C++ 将从属于 C 语言的标准库的文件由 <code>name.h</code> 命名为 <code>cname</code>, 注意 <code>cname</code> 其中定义的名字都从属于 <code>std</code> 标准库命名空间，但是 <code>name.h</code> 则不是。因此，为了方便，统一使用 <code>cname</code>。</p></blockquote></li></ul><h4 id="使用范围-for-语句"><a href="#使用范围-for-语句" class="headerlink" title="使用范围 for 语句"></a>使用范围 for 语句</h4><p>&emsp;C++ 提供了范围 <code>for</code> 语句，能够依次遍历序列中的每个元素并执行某种操作。语法格式如下，<code>expression</code> 是一个序列对象，<code>declaration</code> 是一个循环变量，用于访问序列中的每个元素。每次迭代，<code>declaration</code> 部分都会初始化为<strong>下一个元素</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span>declaration<span class="token operator">:</span> expression<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    statement<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="使用范围-for-语句改变字符串中的字符"><a href="#使用范围-for-语句改变字符串中的字符" class="headerlink" title="使用范围 for 语句改变字符串中的字符"></a>使用范围 for 语句改变字符串中的字符</h5><p>&emsp;如果想要改变字符串中的字符，需要循环变量定义为引用类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>c <span class="token operator">:</span> s<span class="token punctuation">)</span>    c <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// HELLO, WORLD!!!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="只处理一部分字符"><a href="#只处理一部分字符" class="headerlink" title="只处理一部分字符"></a>只处理一部分字符</h4><p>&emsp;C++ 提供两种方法处理字符串中的单个或者部分字符，一种是使用下标，另一种是使用<strong>迭代器</strong>，后面会进一步学习。<br>&emsp;下标运算符 <code>[]</code>, 其中接收的参数类型是 <code>string::size_type</code> ，返回该位置上的字符的引用(既能得到所指的对象，而且能作为左值给这个对象赋值)。注意下标必须大于 0，小于 <code>s.size()</code>。</p><h2 id="3-3-标准库类型-vector"><a href="#3-3-标准库类型-vector" class="headerlink" title="3.3 标准库类型 vector"></a>3.3 标准库类型 vector</h2><p>&emsp;<code>vector</code> 表示<strong>给定某种类型的可变长序列</strong>，使用 <code>vector</code> 类型必须首先包含 <code>vector</code> 头文件。<br>&emsp;C++ 中有<strong>类模板</strong>和<strong>函数模板</strong>，<code>vector</code> 属于类模板, 模板本身并不是类或者函数，它是一份类或者函数的编写说明，编译器将根据模板创建类或者函数的过程称为<strong>实例化</strong>。在实例化时，通过模板名字后面的<strong>尖括号</strong>，我们需要提供一些额外信息来指定模板实例化成什么样的类或者函数。</p><h3 id="3-3-1-定义和初始化-vector-对象"><a href="#3-3-1-定义和初始化-vector-对象" class="headerlink" title="3.3.1 定义和初始化 vector 对象"></a>3.3.1 定义和初始化 vector 对象</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v1<span class="token punctuation">;</span> <span class="token comment">// 元素类型为 int 的空 vector</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v2</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 元素类型为 int , v1 的副本</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span> <span class="token comment">// 等价于 vector&lt;int> v2(v1)</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v3<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// v3 包含了 3 个元素，分别是1，2，3</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v3 <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 等价于 vector&lt;int> v3&#123;1,2,3&#125;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v4</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// v4 包含了 n 个值初始值的元素，这里是 0</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v5</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// v5 包含了 n 个初始值为 val 的元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h4><p>&emsp;<code>vector&lt;int&gt; v4(n)</code>该语句使得 v4 包含了 n 个值初始值的元素，意味着这些元素的初始值由元素类型决定，如果元素是内置类型，那么初始值为 0，如果元素是某种类类型，那么元素由类进行默认初始化，注意有些类不提供默认初始化，此时就必须提供初始值。</p><h3 id="3-3-2-向-vector-对象添加元素"><a href="#3-3-2-向-vector-对象添加元素" class="headerlink" title="3.3.2 向 vector 对象添加元素"></a>3.3.2 向 vector 对象添加元素</h3><p>&emsp;使用 <code>vector&lt;int&gt; v3 = &#123;1,2,3&#125;</code> 这样的语句能快速创建少量的已知初始值的 <code>vector</code>, 但是如果数目过多，更好的方法是先创建一个空的 <code>vector</code> 对象，然后再依次添加元素进去，这种方法同样适用于当运行时才知道元素值的情况。事实上，除非所有元素都一样，我们都应当使用这种方法，因为 <code>vector</code> 可以高效快速地添加元素。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>范围 for 循环体内不应该改变其所遍历序列的大小</p></blockquote><h3 id="3-3-3-其他-vector-操作"><a href="#3-3-3-其他-vector-操作" class="headerlink" title="3.3.3 其他 vector 操作"></a>3.3.3 其他 vector 操作</h3><p>&emsp;<code>v.size()</code> 和 <code>v.empty()</code> 、比较 <code>vector</code> 对象、范围 <code>for</code> 循环以及下标运算符都和 <code>string</code> 类型一致，但是有几点需要注意：</p><ol><li><code>v.size()</code> 返回的是 <code>vector&lt;int&gt;::size_type</code>，即需要指明类型（模板类实例化以后才是类）</li><li>只有当元素的值可比较时， <code>vector</code> 对象才能被比较。</li><li>下标运算符只能用来访问已经存在的元素，不能用于添加元素，访问下标不存在的元素是危险行为。</li></ol><h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><p>&emsp;前文介绍到可以使用<strong>下标</strong>访问序列中部分元素，这里提供一种更通用的机制。<strong>迭代器</strong>。所有的标准库容器都能够使用迭代器，但只有少数几种能够使用下标，严格来说 <code>string</code> 类型不是容器，但是它也可以使用迭代器。</p><ol><li>像指针一样，迭代器提供了一种<strong>间接访问对象</strong>的方式，其对象就是容器中的元素或者 <code>string</code> 类型中的字符。</li><li>使用迭代器能够访问某个对象，也能够从一个元素移动到另一个元素。</li><li>迭代器分为<strong>有效和无效</strong>，有效的迭代器指向<strong>某个元素</strong>或者<strong>尾元素的下一个位置</strong>，其他情况都属于无效。</li></ol><h3 id="3-4-1-使用迭代器"><a href="#3-4-1-使用迭代器" class="headerlink" title="3.4.1 使用迭代器"></a>3.4.1 使用迭代器</h3><p>&emsp;拥有迭代器的容器类型，同时拥有返回迭代器的成员函数 <code>begin</code> 和 <code>end</code>。其中，<code>end</code> 指向的是<strong>尾后元素</strong>，表示处理完了容器的所有类型。当容器为空时，<code>begin</code> 和 <code>end</code> 返回<strong>同一个迭代器</strong>(指向尾后)，可以进行判空。一般来说，像 <code>size</code> 函数一样，我们并不关心返回值的类型是什么，只需要用类型说明符 <code>auto</code> 来接收。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> b <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//指向第一个元素、尾后元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>迭代器的类型</p><ol><li>实际上，那些拥有迭代器的标准库类型使用 <code>iterator</code> 和 <code>const_iterator</code> 来表示迭代器的类型，如<code>vector&lt;int&gt;::iterator</code>、<code>vector&lt;int&gt;::const_iterator</code>, 类似于指针和指向常量指针的关系，如果<strong>容器或者 <code>string</code> 对象</strong>是常量，那么 <code>end</code> 和 <code>begin</code> 返回的就是 <code>const_iterator</code> , 它<strong>只能读不能写</strong>。</li><li>有时，为了专门得到 <code>const_iterator</code> 来控制迭代器的读写权限，C++ 11 新标准引入了两个新函数 <code>cbegin</code> 和 <code>cend</code>, 不论容器或者 <code>string</code> 对象是否是常量，都返回 <code>const_iterator</code> 。</li></ol></blockquote><h4 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h4><h5 id="访问所指元素"><a href="#访问所指元素" class="headerlink" title="访问所指元素"></a>访问所指元素</h5><p>&emsp;和指针类似，通过解引用符 <code>*</code> 来得到所指元素的引用。<strong>只有</strong>当迭代器确实指向某个元素时，才能够进行解引用访问它，否则这样的行为都是未定义的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string s <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">behin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// 判空</span>    <span class="token keyword">auto</span> it <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>it <span class="token operator">=</span> <span class="token function">tolower</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello, world!</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h5><p>&emsp;迭代器能够使用递增运算符 <code>++</code> 来从一个元素移动到下一个元素上，递减运算符 <code>--</code> 能够移动到上一个元素上。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string s <span class="token operator">=</span> <span class="token string">"tobias"</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span>it <span class="token operator">=</span> <span class="token function">toupper</span><span class="token punctuation">(</span><span class="token operator">*</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TOBIAS</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>C++ 常用 <code>!=</code> 而不是 <code>&lt;</code> 来做循环遍历的条件，因为在大部分的迭代器中都没有定义 <code>&lt;</code> 运算符。</p></blockquote><h5 id="结合解引用和成员访问操作"><a href="#结合解引用和成员访问操作" class="headerlink" title="结合解引用和成员访问操作"></a>结合解引用和成员访问操作</h5><p>&emsp;有时候，我们希望先对迭代器解引用然后访问所指对象的成员，如 <code>(*it).empty()</code> , 需要分两步进行，为了简化上述操作，C++ 定义了箭头运算符 <code>-&gt;</code> , 简化为 <code>it-&gt;empty()</code>。</p><blockquote><p>和范围 for 循环一样，迭代器循环体内不应该改变其所遍历序列的大小 </p></blockquote><h3 id="3-4-2-迭代器的运算"><a href="#3-4-2-迭代器的运算" class="headerlink" title="3.4.2 迭代器的运算"></a>3.4.2 迭代器的运算</h3><p>&emsp; 因为 <code>string</code> 和 <code>vector</code> 是有序的，所以它们的迭代器提供了更多的运算符，可以使得迭代器每次移动跨过更多的元素(<code>+ n, - n</code>)，同时也支持进行关系运算(<code>&gt;, &lt;, &gt;=, &lt;=</code>)。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 二分搜索</span><span class="token keyword">auto</span> beg <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> mid <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> beg<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 等价于 auto mid = text.begin() + text.size() / 2;</span><span class="token keyword">while</span><span class="token punctuation">(</span>mid <span class="token operator">!=</span> end <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>mid <span class="token operator">!=</span> sought<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sought <span class="token operator">&lt;</span> <span class="token operator">*</span>mid<span class="token punctuation">)</span>        end <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token keyword">else</span>        beg <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    mid <span class="token operator">=</span> beg <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> beg<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>只要两个迭代器指向的是<strong>同一个容器</strong>中的元素或者尾后元素，就能够进行减法运算。<code>string</code> 和 <code>vector</code> 迭代器中都定义了带符号整数 <code>difference_type</code> ，两个迭代器相减得到的类型，表示两个迭代器之间的距离。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer 第二章 变量和基本类型</title>
      <link href="/2022/06/21/c-primer-2/"/>
      <url>/2022/06/21/c-primer-2/</url>
      
        <content type="html"><![CDATA[<p>数据的类型决定了程序中数据和操作的意义。</p><h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h2><p>&emsp;C++ 的基本内置类型包括<strong>算术类型</strong>和<strong>空类型(void)</strong></p><h3 id="2-1-1-算术类型"><a href="#2-1-1-算术类型" class="headerlink" title="2.1.1 算术类型"></a>2.1.1 算术类型</h3><p>算术类型分为<strong>整型</strong>和<strong>浮点型</strong>。</p><ol><li>整型<ul><li><code>bool</code> 布尔类型 真或假</li><li><code>char</code> 字符 空间大小应当确保可以存放机器基本字符集中任意字符对应的数字值，因此大小和一个机器字节一样。</li><li><code>wchar_t</code> 宽字符 空间大小应当确保可以存放机器最大扩展字符集中任意字符对应的数字值</li><li><code>char16_t</code> Unicode字符</li><li><code>char32_t</code> Unicode字符</li><li><code>short</code> 短整型 通常两个字节(16bit)表示</li><li><code>int</code> 整型 通常四个字节(32bit)表示</li><li><code>long</code> 长整型 通常四个字节(32bit)表示</li><li><code>long long</code> 长整型 通常八个字节(64bit)表示</li></ul></li><li>浮点型<ul><li><code>float</code> 单精度浮点型 通常一个字(32bit)表示，7个有效位</li><li><code>double</code> 双精度浮点型 通常两个字(64bit)表示，16个有效位</li><li><code>long double</code> 扩展精度浮点型 通常三或四个字(96或128bit)表示, 用于有特殊浮点要求的硬件</li></ul></li></ol><blockquote><p>字节与字<br>可寻址的最小内存块称为“字节(byte)”, 存储的基本单元叫做”字(word)”<br>一个字节要确保可以存放机器基本字符集中任意字符对应的数字值，大小为 8bit<br>一个字由四或八个字节构成，大小为 32或64bit</p></blockquote><h4 id="带符号类型和无符号类型"><a href="#带符号类型和无符号类型" class="headerlink" title="带符号类型和无符号类型"></a>带符号类型和无符号类型</h4><p>&emsp;除去布尔型和扩展性字符型以外，算术类型还可以分为带符号类型和无符号类型。无符号类型的所有比特都是用来存储值的，带符号类型有一比特是用来存储符号的。</p><ol><li>带符号类型: <code>short</code> ,<code>int</code>, <code>long</code>, <code>long long</code>, 前面可以加 <code>unsigned</code> 变为无符号类型，不可能为负。<code>unsigned int</code> 可以缩写为 <code>unsigned</code>。</li><li>无符号类型: <code>float</code>, <code>double</code>, <code>long double</code> 不能变为带符号类型</li><li>不确定类型: <code>char</code>，表现为 <code>signed</code> 和 <code>unsigned</code> 两种，具体哪种视编译器而定。</li></ol><h4 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h4><ol><li>已知不为负数时，要用无符号类型。</li><li><code>long</code> 和 <code>int</code> 有一样的尺寸，当 <code>int</code> 不够时，直接使用 <code>long long</code>。</li><li>算术表达式中不要使用 <code>char</code> 或 <code>bool</code>。因为 <code>char</code> 类型在不同的编译器下可能是带符号的，也可能是不带符号的。</li><li>浮点数选用 <code>double</code>。<code>float</code> 和 <code>double</code> 计算开销差不多，但是 <code>double</code> 所表示的范围更大。</li></ol><h3 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h3><ol><li>非布尔类型的算术值赋给布尔类型，初始值为0的结果为false, 否则为true。</li><li>布尔值赋给非布尔类型时，初始值为false的结果为0，否则为1。</li><li>浮点数赋给整型时，截断小数部分。</li><li>整型赋给浮点数时，容量够的情况下，小数部分记为0。</li><li>赋给无符号类型一个超过其范围的值时，结果为初始值对无符号类型表示的数值总数取模后的余数。</li><li>赋给带符号类型一个超过其范围的值时，结果为<strong>未定义的</strong>，应尽量避免这种事情发生。</li></ol><h4 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h4><ol><li>当一个算术表达式中既有无符号数和带符号数，带符号数会自动转换成无符号数。</li><li>无符号数减去一个数，无论是不是无符号数，结果都会确保不会为负数（方法和赋给无符号数一个超过其范围的值一样）。</li></ol><h3 id="2-1-3-字面值常量"><a href="#2-1-3-字面值常量" class="headerlink" title="2.1.3 字面值常量"></a>2.1.3 字面值常量</h3><p>&emsp;字面值常量的形式和值决定了其数据类型。</p><h4 id="整型和浮点型字面值"><a href="#整型和浮点型字面值" class="headerlink" title="整型和浮点型字面值"></a>整型和浮点型字面值</h4><ol><li>整型：<ul><li>十进制: 在容量够的情况下，选择 <code>int</code>, <code>long</code>, <code>long long</code> 中尺寸最小的那个。</li><li>八进制(0)和十六进制(0x)：因为更大，所以可能是无符号数，在容量够的情况下，选择 <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code>, <code>unsigned long long</code> 中尺寸最小的那个。</li></ul></li><li>字符型(E)：<br><code>double</code></li></ol><h4 id="字符和字符串字面值"><a href="#字符和字符串字面值" class="headerlink" title="字符和字符串字面值"></a>字符和字符串字面值</h4><ol><li>字符(‘’)<br> <code>char</code></li><li>字符串(“”)<br> 常量字符组成的数组(以 <code>&#39;\0&#39;</code> 结尾)</li></ol><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>&emsp;C++ 语言中有一些特殊含义的字符，如单引号，双引号，回车符等，需要使用到<strong>转义字符</strong>，如<code>\&#39;</code>,<code>\&quot;</code>,<code>\r</code>。还可以使用泛化的<strong>转义序列</strong>，其形式是 <code>\x</code> 后面跟十六进制数，或者 <code>\</code> 跟八进制数，数字部分就是字符集中字符对应的数值，如 <code>\40</code>(空格)。</p><h4 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h4><ol><li>字符和字符串字面值：前缀<ul><li><code>u</code>: <code>char16_t</code></li><li><code>U</code>: <code>char32_t</code></li><li><code>L</code>: <code>wchar_t</code></li><li><code>u8</code>: UTF-8 字符串</li></ul></li><li>整型：后缀<ul><li><code>u or U</code>: 在容量够的情况下，选择 <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code> 中尺寸最小的那个。</li><li><code>l or L</code>: 在容量够的情况下，选择 <code>long</code>, <code>unsigned long</code>, <code>long long</code>, <code>unsigned long long</code> 中尺寸最小的那个。</li><li><code>ll or LL</code>: 在容量够的情况下，选择 <code>long long</code>, <code>unsigned long long</code> 中尺寸最小的那个。</li><li><code>U</code> 和 <code>L</code> 可以一起使用, 如 <code>UL</code> 表示在容量够的情况下，选择 <code>unsigned long</code>, <code>unsigned long long</code> 中尺寸最小的那个。</li></ul></li><li>浮点型：后缀<ul><li><code>f or F</code>： <code>float</code></li><li><code>l or L</code>: <code>long double</code></li></ul></li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li>布尔值: <code>true</code> 和 <code>false</code></li><li>指针: <code>nullptr</code>是指针的一个字面值。</li></ol><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><p>&emsp;变量就是一个具名的，可供程序操作的<strong>存储空间</strong>。同时，每个变量都有其数据类型，数据类型决定<strong>存储空间的大小以及布局格式</strong>，变量所能参与的<strong>运算操作</strong>。一般来说，对象就是变量，变量就是对象。</p><h3 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h3><h4 id="初始化：后面会进一步学习"><a href="#初始化：后面会进一步学习" class="headerlink" title="初始化：后面会进一步学习"></a>初始化：后面会进一步学习</h4><ol><li>变量的初始化不是<strong>赋值</strong>，初始化时创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，然后用一个新值替代。</li><li>列表初始化<br>形如<code>int i&#123;3.14&#125;</code>，如果使用列表初始化时存在初始值丢失信息的风险时，编译器会报错。</li></ol><h4 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h4><ol><li>定义于任何<strong>函数体外</strong>的<strong>内置类型</strong>的变量被<strong>默认初始化</strong>为0，在<strong>函数体内</strong>的<strong>内置类型</strong>变量不会被默认初始化，其值是<strong>未定义的</strong>，应当避免这种情况发生。</li><li>对于<strong>类</strong>的对象的初始化，其是否可以不经初始化就定义对象由类自己决定，没有进行显式地初始化，其默认初始值也由类决定。</li></ol><h3 id="2-2-2-变量声明和定义的关系"><a href="#2-2-2-变量声明和定义的关系" class="headerlink" title="2.2.2 变量声明和定义的关系"></a>2.2.2 变量声明和定义的关系</h3><p>&emsp;先明确声明和定义的区别，变量的<strong>声明</strong>规定了变量的类型和名字，表明此处只是声明，定义需要去别的地方找，<strong>定义</strong>在声明的基础上还<strong>申请存储空间</strong>，同时还可能会为变量赋一个初始值。在 C++ 中，必须遵循<strong>单定义规则</strong>，即变量能且只能被定义一次，但是能够被多次声明，声明一个变量要用到 <code>extern</code> 关键字，<code>extern int i</code> 语句表示声明而非定义变量 <code>i</code> , 表示该数在别处进行了定义，此处只进行声明。此外，<strong>任何包含显示初始化的声明都是定义</strong>，因此 <code>extern int i = 10</code> 这条语句也算是定义。常用在变量定义在一个文件中，但是在多个文件使用的情况，此时其他文件就需要对其进行声明，不能进行重复定义。</p><blockquote><p>静态类型<br>C++ 的类型检查发生在编译阶段，编译器必须知道每一个变量对应的数据类型。</p></blockquote><h3 id="2-2-3-标识符"><a href="#2-2-3-标识符" class="headerlink" title="2.2.3 标识符"></a>2.2.3 标识符</h3><ol><li>要能体现具体含义。</li><li>长度没有限制，对大小写敏感。</li><li>不能使用 C++ 关键字或者保留字作为标识符。</li><li>下划线后面不能继续跟下划线和大写字母。</li><li>变量名一般用小写，类名大写字母开头。</li><li>定义在函数体外的标识符不能以下划线开头。</li><li>由字母、数字、下划线组成，不能以数字开头。</li><li>标识符用多个单词组成，用下划线连接或者驼峰。</li></ol><h3 id="2-2-4-名字的作用域"><a href="#2-2-4-名字的作用域" class="headerlink" title="2.2.4 名字的作用域"></a>2.2.4 名字的作用域</h3><ol><li>全局作用域：<strong>声明</strong>在函数体之外的变量或者函数的作用域，声明之后，全局作用域内的名字在整个程序的范围内都可以使用。</li><li>块作用域：<code>&#123;&#125;</code></li><li>嵌套作用域：<ul><li>作用域一旦声明了某个名字，它所嵌套的所有作用域中都能访问该名字。</li><li>允许在内层作用域中重复定义外层作用域已有的名字，进行覆盖，但是<strong>不建议这么做</strong>。</li><li>内部变量的使用遵循<strong>就近原则</strong>，但是可以用作用域运算符 <code>::</code> 访问全局作用域的变量。</li></ul></li></ol><h2 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h2><p>复合类型指的是基于其他类型定义的类型，比如引用和指针。</p><h3 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h3><h4 id="引用即别名"><a href="#引用即别名" class="headerlink" title="引用即别名"></a>引用即别名</h4><ol><li>引用就是为对象起了另外一个名字，不同于变量的定义，定义引用时，程序会将引用和它的初始值（变量）进行绑定，一旦初始化完成，引用会和其初始化的对象一直绑定在一起，无法再进行更改，因此<strong>引用必须初始化</strong>。</li><li>引用实际上就是对象的别名，因此它不是新的对象，没有自己的存储空间，所以<strong>不能定义引用的引用</strong>, 也<strong>没有指向引用的指针</strong>。</li></ol><h4 id="引用的定义"><a href="#引用的定义" class="headerlink" title="引用的定义"></a>引用的定义</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 定义变量</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> r<span class="token punctuation">,</span> r2 <span class="token operator">=</span> r<span class="token punctuation">;</span> <span class="token comment">// r1 是引用，r2 不是引用 </span><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span> <span class="token comment">// 定义变量</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> d<span class="token punctuation">;</span> <span class="token comment">// 错误，一般情况下，类型需要严格匹配</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r3 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 错误，没有字面值的引用，必须是对象的引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="引用的使用：直接换名字"><a href="#引用的使用：直接换名字" class="headerlink" title="引用的使用：直接换名字"></a>引用的使用：直接换名字</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span> <span class="token comment">// 定义变量</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal1 <span class="token operator">=</span> ival<span class="token punctuation">;</span> <span class="token comment">// 定义 ival 的引用 refVal1</span><span class="token keyword">int</span> i1 <span class="token operator">=</span> refVal<span class="token punctuation">;</span> <span class="token comment">// 用 ival 的值初始化 i1</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal2 <span class="token operator">=</span> refVal1<span class="token punctuation">;</span> <span class="token comment">// 这里不是引用的引用，而是又定义了 ival 的引用 refVal2</span>refVal2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// ival = 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>引用：左值引用<br>右值引用主要用于<strong>内置类</strong>，后面会进一步学习<br>左值指的是可以<strong>取地址的，有名字的，非临时的</strong>变量；右值指的是<strong>不能取地址，无名字的，临时的</strong>变量</p></blockquote><h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><h4 id="与引用的联系"><a href="#与引用的联系" class="headerlink" title="与引用的联系"></a>与引用的联系</h4><ol><li>相同的是指针和引用都实现了对其他对象的间接访问，都是基于其他类型而定义的类型。</li><li>不同：<ul><li>指针是对象，存放的时某个对象的地址，允许赋值和拷贝，即允许更换指向的对象。</li><li>不需要在定义时进行初始化。</li></ul></li></ol><h4 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span> <span class="token comment">// 取地址符 &amp;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>dp <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// 错误，般情况下，类型需要严格匹配</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>val<span class="token punctuation">;</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 解引用符 *, 通过指针修改 val 的值</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>r<span class="token punctuation">;</span> <span class="token comment">// 这里不是引用的指针，p仍然是指向 ival 的指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h4><ol><li>指向一个对象：只有确实指向了某个对象，才能使用解引用符间接访问对象</li><li>指向紧邻对象所占空间的下一个位置：后面会进一步学习</li><li>空指针：在条件判断时为 <code>false</code><ul><li>NULL：<strong>预处理变量</strong>，在编译之前，预处理器会将其替换为 0</li><li>0 字面值</li><li>nullptr：建议</li></ul></li><li>无效指针：未定义的，使用未定义的指针很危险，因此要尽量避免这种情况，将所有的指针都进行初始化，即便不知道指向哪里，也初始化为空指针</li></ol><h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h4><p>&emsp;<code>void*</code> 是一个特殊的指针，能够<strong>存放任意对象的地址</strong>。从 <code>void*</code> 的视角看内存空间就是内存空间，不能通过这个指针访问内存空间的对象，因为不知道对象的具体的类型，也就无法确定这个对象能够做哪些操作，这在编译阶段是不被允许的。 </p><h3 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 基本数据类型 （类型修饰符）声明符： int int* int&amp;</span><span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 第二种方法容易被误导：int* int int&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>&emsp;指针是内存中的对象，因此允许把指针的地址再存放到另外一个指针中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>pi <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ppi <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment">// 指向指针的指针</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pi <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token operator">*</span>ppi <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ppi <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 1024 1024 0x61ff08 (pi的地址)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h4><p>&emsp;引用本身不是对象，因此不能定义指向引用的指针，但是指针是对象，我们能定义指针的引用。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>r <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// 指针的引用 从右往左解读</span>r <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token operator">*</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 等价于 *p = 0 等价于 i = 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-const-限定符"><a href="#2-4-const-限定符" class="headerlink" title="2.4 const 限定符"></a>2.4 const 限定符</h2><p>&emsp;<code>const</code> 修饰的对象内容不能被改变，因此 <code>const</code> 对象一定要进行初始化。</p><h3 id="默认状态下，-const-对象仅在文件内有效"><a href="#默认状态下，-const-对象仅在文件内有效" class="headerlink" title="默认状态下， const 对象仅在文件内有效"></a>默认状态下， const 对象仅在文件内有效</h3><ol><li>不同文件，不同的 <code>const</code> 对象，但是值一样<br> 首先理解编译器如何处理 <code>const</code> 对象，编译器会在<strong>编译阶段</strong>把用到该变量的地方全部替换为初始值，因此为了进行替换，编译器必须知道 <code>const</code> 对象的初始值，如果程序包含多个文件，每个用了 <code>const</code> 对象的文件都必须在<strong>编译阶段</strong>访问到初始值，由于只有在链接阶段才能访问到其他文件对于变量的定义，因此不能使用”一次定义，重复声明“的方法，每一个用到 <code>const</code> 对象的文件实际上都是分别独立地对其进行了定义，<code>const</code> 对象仅在文件内有效。通常的做法就是直接将 <code>const</code> 对象的<strong>定义</strong> <code>const int val = 10</code> 放在头文件中，在不同的文件中将会定义独立的变量。</li><li>不同文件，同一个 <code>const</code> 对象<br> 某些时候有这样一种 <code>const</code> 对象，它的初始值不是一个<strong>常量表达式</strong>，但又确实有必要在文件中共享。因为当运行时确定结果时，所有的目标文件已经链接好，不再希望在不同的文件中生成独立的变量，我们希望 <code>const</code> 对象像其他对象一样工作，在一个文件中定义，在多个文件中声明并使用它。解决的办法就是在<strong>声明和定义</strong>都添加 <code>extern</code> 关键字。源文件中定义 <code>extern const int val = f()</code>, 头文件中声明 <code>extern const int val</code>。</li></ol><h3 id="2-4-1-const-的引用"><a href="#2-4-1-const-的引用" class="headerlink" title="2.4.1 const 的引用"></a>2.4.1 const 的引用</h3><p>&emsp;C++ 允许把引用绑定到常量对象上。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">// 对常量的引用，简称常量引用</span>r1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 错误 不允许通过常量引用修改常量的值</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">// 错误 不允许用非常量引用指向常量，否则可以更改常量的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常量引用的特殊情况："><a href="#常量引用的特殊情况：" class="headerlink" title="常量引用的特殊情况："></a>常量引用的特殊情况：</h4><p>&emsp;一般来说，引用的类型要与被绑定的对象类型严格匹配，但是对于常量引用，在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。实际上，<strong>常量引用强调的是对引用可参与的操作进行了限定，而对于引用的对象本身是不是一个常量，是不是相同的类型等都没有做出要求</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>r1 <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 普通引用</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 常量引用</span>r1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 正确 等价于 i = 0 </span>r2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>常量引用的作用<br>允许为一个常量引用绑定非常量的对象、字面值、其他类型变量、甚至是一个一般表达式。主要用于函数的形参，防止误操作。</p></blockquote><blockquote><p>本质上，当一个常量引用绑定到其他类型上时，绑定的是一个<strong>临时量</strong>对象，该临时量对象与常量引用的类型一致。如果该引用不是常量，那么可以通过引用修改临时量的值，这是没有意义的，因此 C++ 将类型不匹配的引用视为非法操作。<br><code>double d = 3.14;</code><br><code>const int &amp;r = d;</code> // 正确 临时量 <code>const int temp = d; const int &amp;r = temp;</code></p></blockquote><h3 id="2-4-2-const-和指针"><a href="#2-4-2-const-和指针" class="headerlink" title="2.4.2 const 和指针"></a>2.4.2 const 和指针</h3><p>&emsp;与常量引用类似，C++ 允许存在指向常量的指针。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment">// 指向常量的指针</span><span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// 错误 指向常量的指针不能用于修改常量</span><span class="token keyword">double</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>pi<span class="token punctuation">;</span> <span class="token comment">// 错误 不允许用普通指针指向常量，否则可以更改常量的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="指向常量指针的特殊情况"><a href="#指向常量指针的特殊情况" class="headerlink" title="指向常量指针的特殊情况"></a>指向常量指针的特殊情况</h4><p>&emsp;类似地，指向常量的指针也没有规定所指的对象必须是一个常量，其强调的同样是不能通过该指针修改对象的值，但是不同于引用，仍然要求基本数据类型要一致。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span><span class="token operator">*</span>cptr <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> <span class="token comment">// 错误</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="const-指针（常量指针）"><a href="#const-指针（常量指针）" class="headerlink" title="const 指针（常量指针）"></a>const 指针（常量指针）</h4><p>&emsp;指针是对象而引用不是，因此就像其他对象类型一样，允许将指针本身定为常量，意味着<strong>必须进行初始化，并且不能再修改</strong>，但是能够通过解引用符修改指向对象的值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> ip <span class="token operator">=</span> <span class="token operator">&amp;</span>ival<span class="token punctuation">;</span> <span class="token comment">// 常量指针 从右向左解读</span><span class="token operator">*</span>ip <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span><span class="token keyword">double</span> dval <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span><span class="token keyword">const</span> dp <span class="token operator">=</span> <span class="token operator">&amp;</span>dval<span class="token punctuation">;</span> <span class="token comment">// 指向常量的常量指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-3-顶层-const-和底层-const"><a href="#2-4-3-顶层-const-和底层-const" class="headerlink" title="2.4.3 顶层 const 和底层 const"></a>2.4.3 顶层 const 和底层 const</h3><p>&emsp;顶层 <code>const</code> 表示任意的对象是常量，底层 <code>const</code> 则与指针和引用等复合类型的基本类型相关，表示该指针或者引用有没有能力修改所指对象的值。因为指针是对象，因此存在顶层和底层 <code>const</code> 指针。<br>&emsp;对于底层 <code>const</code> 的拷贝有以下限制，拷贝的过程不能赋予修改权限。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// 底层 const</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// 顶层 const</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// 底层和顶层 const</span><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment">// 错误 不能将底层 const 拷贝到普通指针</span><span class="token keyword">int</span> <span class="token operator">*</span>p4 <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>p1 <span class="token operator">=</span> p4<span class="token punctuation">;</span> <span class="token comment">// 正确 允许将普通指针拷贝到底层 const</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-4-constexpr-和常量表达式"><a href="#2-4-4-constexpr-和常量表达式" class="headerlink" title="2.4.4 constexpr 和常量表达式"></a>2.4.4 constexpr 和常量表达式</h3><p>&emsp;常量表达式是指<strong>值不会改变</strong>并且<strong>在编译过程中就能得到计算结果</strong>的表达式。</p><h4 id="constexpr-变量"><a href="#constexpr-变量" class="headerlink" title="constexpr 变量"></a>constexpr 变量</h4><p>&emsp;C++ 11 新标准规定，允许将一个变量声明为 <code>constexpr</code> 以便由编译器来验证变量的值是否是一个常量表达式。形如 <code>constexpr int sz = size()</code> 这样的语句同样有可能正确，在后面的学习中会了解到一种 <code>constexpr</code> 函数，它能够在编译阶段就计算其结果，因此能够初始化 <code>constexpr</code> 变量。</p><h4 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h4><p>&emsp;能够用来声明 <code>constexpr</code> 变量的类型叫字面值类型，由于 <code>constexpr</code> 变量的特点，这种类型应当是显而易见，容易得到的，如算术类型，引用和指针。<br>&emsp;对于指针和引用能够声明为 <code>constexpr</code> 变量，但是对它们的初始值有一定的限制。</p><ol><li><code>constexpr</code> 指针和引用必须指向某个<strong>固定地址</strong>的对象：<ul><li>全局变量：定义在所有函数体外的</li><li>静态局部变量：在函数体内用 <code>static</code> 关键字修饰的</li></ul></li><li><code>constexpr</code> 指针的初始值还可以是 <code>nullptr</code></li></ol><h4 id="指针和-constexpr"><a href="#指针和-constexpr" class="headerlink" title="指针和 constexpr"></a>指针和 constexpr</h4><p>&emsp;用 <code>constexpr</code> 修饰的指针是<strong>顶层</strong> <code>const</code> ，表示其值不会改变，必须初始化，在编译期间就能够确定结果。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">constexpr</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// 指向常量的常量指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h2><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><p>&emsp;类型别名是一个名字，它是某种类型的同义词，使用类型别名能够让复杂的类型名称变得简单明了，方便记忆和使用。<br>&emsp;使用类型别名的两种方法：</p><ol><li><code>typedef</code><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">double</span> wages<span class="token punctuation">;</span> <span class="token comment">// wages 是 double 的别名</span><span class="token keyword">typedef</span> wages <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// 支持类型修饰符实现复合类型的别名，p 是 double* 的别名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><code>using =</code><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> SI <span class="token operator">=</span> Sales_item<span class="token punctuation">;</span> <span class="token comment">// SI 是 Sales_item 的别名</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h4><p>&emsp;当使用复合类型的别名指代常量以及复合类型时，容易产生错误。方法是可以将 <code>pstring</code> 直接看成一个基本数据类型，如 <code>int</code>，理解其整体含义，然后再进行替换。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>pstring<span class="token punctuation">;</span> <span class="token comment">// pstring 是 char* 的别名</span><span class="token keyword">const</span> pstring cstr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// cstr 是指向 char 的常量指针，const 是顶层</span><span class="token keyword">const</span> pstring <span class="token operator">*</span>ps<span class="token punctuation">;</span> <span class="token comment">// cstr 是一个指针，指向的对象是指向 char 的常量指针，const 是底层</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-5-2-auto-类型说明符"><a href="#2-5-2-auto-类型说明符" class="headerlink" title="2.5.2 auto 类型说明符"></a>2.5.2 auto 类型说明符</h3><p>&emsp;在编程时需要将表达式的值赋给变量，声明变量的时候就需要确定表达式的类型，C++ 11 新标准引入了 <code>auto</code> 类型说明符，用它让编译器替我们去分析表达式所属的类型。因此，<code>auto</code> 定义的变量必须有初始值，通过初始值确定类型。</p><h4 id="auto-的使用"><a href="#auto-的使用" class="headerlink" title="auto 的使用"></a>auto 的使用</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// i 是整型，r 是整型引用</span><span class="token keyword">auto</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// 错误 多个声明符的时候，类型要保持一致</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="复合类型、常量和-auto"><a href="#复合类型、常量和-auto" class="headerlink" title="复合类型、常量和 auto"></a>复合类型、常量和 auto</h4><p>&emsp;当涉及复合类型、常量和 <code>auto</code> 时的情况往往比较复杂，遵循的基本规则:</p><ol><li>如果声明的不是<strong>复合类型</strong>， <code>auto</code> 会忽略顶层 <code>const</code> ， 保留底层 <code>const</code>。</li><li>如果声明的是<strong>复合类型</strong>，那么同样需要考虑顶层 <code>const</code>。<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cr <span class="token operator">=</span> ci<span class="token punctuation">,</span> <span class="token operator">*</span>cp <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment">// 常量 常量引用 指向常量的指针</span><span class="token keyword">auto</span> a <span class="token operator">=</span> cp<span class="token punctuation">;</span> <span class="token comment">// 保留底层 const, a 是一个指向常量的指针</span><span class="token keyword">auto</span> b <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">// 忽略掉顶层 const, b 是一个整型</span><span class="token keyword">const</span> <span class="token keyword">auto</span> b1 <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">// 增加顶层 const, b 是一个整型常量</span><span class="token keyword">auto</span> c <span class="token operator">=</span> cr<span class="token punctuation">;</span> <span class="token comment">// 找引用绑定的对象 ci, c 是一个整型</span><span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">// d 是一个整型指针</span><span class="token keyword">auto</span> e <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment">// 对常量对象取地址也是一种底层 const，e 是一个指向整型常量的指针</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>f <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">// f 是一个整型常量引用</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>g <span class="token operator">=</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>h <span class="token operator">=</span> <span class="token operator">&amp;</span>ci<span class="token punctuation">;</span> <span class="token comment">// 错误 类型不一致，i 是 int ，&amp;ci 是 const int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="2-5-3-decltype-类型指示符"><a href="#2-5-3-decltype-类型指示符" class="headerlink" title="2.5.3 decltype 类型指示符"></a>2.5.3 decltype 类型指示符</h3><p>&emsp;有时候希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值作为变量的初始值。C++ 11 新标准引入了 <code>decltype</code> 类型指示符，只得到类型，而不返回结果。</p><h4 id="decltype-的使用"><a href="#decltype-的使用" class="headerlink" title="decltype 的使用"></a>decltype 的使用</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> sum <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 并不实际调用 f， 将其返回类型作为变量 sum 的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="和-auto-的不同"><a href="#和-auto-的不同" class="headerlink" title="和 auto 的不同"></a>和 auto 的不同</h4><p>&emsp;如果 <code>decltype</code> 使用的是<strong>变量</strong>，则返回的是该变量的类型（包括<strong>引用、顶层</strong> <code>const</code>）, <strong>注意</strong>引用只有在此处不作为绑定对象的同义词出现。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">0.</span> <span class="token operator">&amp;</span>cj <span class="token operator">=</span> ci<span class="token punctuation">;</span> <span class="token comment">// 整型常量 常量引用</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 整型常量</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 常量引用 绑定到 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="decltype-和引用"><a href="#decltype-和引用" class="headerlink" title="decltype 和引用"></a>decltype 和引用</h4><ol><li>如果 <code>decltype</code> 使用的是<strong>表达式</strong>，返回的是该表达式结果对应的类型。<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span> val<span class="token punctuation">;</span> <span class="token comment">// 整型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>特殊的，<strong>如果该表达式的对象能够作为赋值语句的左值出现，那么就返回一个引用类型。</strong> 因为该表达式既能得到所指的对象，而且能作为左值给这个对象赋值，所以返回的是引用类型。</li></ol><ul><li>解引用<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> r<span class="token punctuation">;</span> <span class="token comment">// 错误 引用必须初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>加括号<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> r<span class="token punctuation">;</span> <span class="token comment">// 错误 引用必须初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 C++ 中的头文件</title>
      <link href="/2022/06/21/c-header/"/>
      <url>/2022/06/21/c-header/</url>
      
        <content type="html"><![CDATA[<h2 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h2><p>&emsp;C++语言支持<strong>分离式编译</strong>(separate compilation)机制，允许将程序分割为多个<strong>源文件</strong>，每个文件独立地进行编译。这意味着，源文件里的东西都是相互独立的，在编译时不需要和其他的源文件进行互通，只需要在编译成<strong>目标文件</strong>时，与其他的目标文件进行一次链接即可。</p><h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><p>&emsp;如果将程序分为多个源文件，那么我们需要有在文件中<strong>共享代码</strong>（函数、变量等）的方法。为了支持分离式编译，C++ 语言将声明和定义区分开来，”定义”就是把一个符号完完整整地描述出来：它是变量还是函数，返回什么类型，需要什么参数等等。而”声明”则只是声明这个符号的存在，即告诉编译器，这个符号是在其他文件中定义的，这里先用着，链接的时候再到别的地方去找它的定义。声明需要用到 <code>extern</code> 关键字，函数的声明自带 <code>extern</code>，而变量的声明需要在变量名前添加关键字 <code>extern</code> ，而且不能显式地初始化变量，因为任何包含了显式初始化的声明都会变成定义。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>&emsp;如果编写程序时需要用到其他文件中的许多函数或者变量，那么声明的部分会变得十分麻烦，为了简化，我们可以将声明的语句全部写到头文件中去，如果需要用到它们，那么通过 <code>#include</code> 预处理命令，预处理器在预处理阶段就会把这些需要的声明全部复制到当前的源文件中。可以看出，头文件并不参与编译，但是其中的源代码会在多个文件中进行编译。因此，由于单定义规则，避免重复定义，头文件中不能存在变量或者函数的定义，只能存在声明语句。</p><h3 id="编写自己的头文件"><a href="#编写自己的头文件" class="headerlink" title="编写自己的头文件"></a>编写自己的头文件</h3><p>&emsp;在编译阶段我们就需要用到类的信息，因此为了确保各个文件中的类的定义一致，类也通常被定义在头文件中, 以便各个文件进行使用.而且类所在头文件的名称一般与类名相同,如 <code>Sales_data</code> 类定义在 <code>Sales_data.h</code> 的头文件中.此外, 头文件允许包含其他头文件, 为了避免多次包含相同的类的定义, 常用到的技术就是<strong>头文件保护符</strong>, 通过定义<strong>预处理变量</strong>, 来控制预处理器的执行, 防止多次包含带来的危险.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">SALES_DATA_H </span><span class="token comment">// 预处理变量</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SALES_DATA_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token keyword">struct</span> <span class="token class-name">Sales_data</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>string bookNo<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> units_sold <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> revenue <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer 第一章 开始</title>
      <link href="/2022/05/11/c-primer-1/"/>
      <url>/2022/05/11/c-primer-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-编写一个简单的-C-程序"><a href="#1-1-编写一个简单的-C-程序" class="headerlink" title="1.1 编写一个简单的 C++ 程序"></a>1.1 编写一个简单的 C++ 程序</h2><h3 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h3><ol><li>每个 C++ 程序都包含一个或者多个函数，其中一个必须是 <code>main</code> 函数，因为操作系统需要调用 <code>main</code> 函数来运行 C++ 程序。</li><li><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><code>main</code> 函数也是函数，形如上段代码，一个函数必须由<strong>返回类型</strong>、<strong>函数名</strong>、<strong>形参列表</strong>和<strong>函数体</strong>四个部分组成。</li><li><code>main</code> 函数的返回值被用来指示程序的运行状态，返回 0 表示成功，非 0 的返回值含义由系统定义，通常用来表示错误类型。</li></ol><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol><li>上段代码中的 <code>int</code> 是一种<strong>内置类型</strong>，即语言自身定义的类型。</li><li>一种类型既定义了数据元素的内容，还定义了这类数据上可以进行的运算。</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li>变量是<strong>地址空间</strong>的别名。</li><li>程序所处理的数据都保存在变量中，而每个变量都有自己的类型，告诉编译器应该如何理解地址空间上的数据：<strong>是什么类型的变量，该变量能进行哪些运算。</strong></li></ol><h3 id="1-1-1-编译、运行程序"><a href="#1-1-1-编译、运行程序" class="headerlink" title="1.1.1 编译、运行程序"></a>1.1.1 编译、运行程序</h3><h4 id="不同的编译器编译源文件"><a href="#不同的编译器编译源文件" class="headerlink" title="不同的编译器编译源文件"></a>不同的编译器编译源文件</h4><ol><li>使用不同的后缀名表示 C++ 源文件，最常见的包括 <code>.cc</code>, <code>.cpp</code>, <code>.cxx</code>, <code>.cp</code> 及 <code>.C</code></li><li>运行 C++ 程序的命令也不相同。</li></ol><h4 id="不同的操作系统"><a href="#不同的操作系统" class="headerlink" title="不同的操作系统"></a>不同的操作系统</h4><ol><li>编译完成后，运行可执行文件：<ul><li>Windows 系统：可以忽略其扩展名<code>.exe</code></li><li>Linux 系统：需要使用全文件名，不可以忽略扩展名<code>.out</code></li></ul></li><li>获得程序的运行状态：<ul><li>Windows 系统：<code>echo %ERRORLEVEL%</code></li><li>Linux 系统：<code>echo $?</code></li></ul></li></ol><h4 id="GNU-编译器"><a href="#GNU-编译器" class="headerlink" title="GNU 编译器"></a>GNU 编译器</h4><p>&emsp;编译命令：<code>g++ test.cpp -o test</code>, 其中 <code>-o test</code> 是编译器参数，指定可执行文件的文件名，Windows 系统是 <code>test.exe</code>，Unix 系统是 <code>test.out</code>。省略的话，会生成 <code>a.exe</code> 或 <code>a.out</code> 可执行文件, 源文件是 <code>test.cpp</code> , 一般有多个源文件进行编译，然后链接目标文件生成可执行文件。</p><h2 id="1-2-初识输入输出"><a href="#1-2-初识输入输出" class="headerlink" title="1.2 初识输入输出"></a>1.2 初识输入输出</h2><h3 id="iostream-库"><a href="#iostream-库" class="headerlink" title="iostream 库"></a>iostream 库</h3><p>&emsp;C++ 语言并未定义任何的输入输出语句，但是提供了一个全面的标准库来提供 IO 机制，其中 <code>iostream</code> 库就是专门用于输入输出的标准库，它属于面向对象类库，包含两个基础类型：<code>istream</code> 和 <code>ostream</code>，分别表示输入和输出<strong>流</strong>。“流”表示<strong>字符序列</strong>，该字符序列从 IO 设备读出或写入 IO 设备。因为随着时间的推移，字符是<strong>顺序地</strong>产生和消耗的，所以称之为“流”。</p><blockquote><p>标准库<br>C++ 标准库可以分为两部分：<br><strong>标准函数库</strong>： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。<br><strong>面向对象类库</strong>： 这个库是类及其相关函数的集合。</p></blockquote><h3 id="标准输入输出对象"><a href="#标准输入输出对象" class="headerlink" title="标准输入输出对象"></a>标准输入输出对象</h3><ol><li>输入对象：<ul><li><code>cin</code>：标准输入</li></ul></li><li>输出对象：<ul><li><code>cout</code>：标准输出</li><li><code>cerr</code>：输出警告和错误信息</li><li><code>clog</code>：输出程序运行时的一般性信息</li></ul></li></ol><p>&emsp;系统会将程序运行的窗口与输入输出对象关联起来（把它们想象成窗口），当读取 <code>cin</code> 对象时，数据将从程序正在运行的窗口读入；当写入 <code>cout</code>, <code>cerr</code> 和 <code>clog</code> 对象时，将会写到程序运行的窗口上。</p><blockquote><p>文件重定向<br><code>test &lt;infile &gt;outfile</code><br>上述命令会让 <code>test.exe</code> 程序从一个名为 <code>infile</code> 的文件读取程序输入，并将输出结果写入到一个名为 <code>outfile</code> 的文件中。</p></blockquote><h3 id="一个使用-IO-库的程序"><a href="#一个使用-IO-库的程序" class="headerlink" title="一个使用 IO 库的程序"></a>一个使用 IO 库的程序</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter two numbers:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">int</span> v1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> v2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">>></span> v1 <span class="token operator">>></span> v2<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The sum of "</span> <span class="token operator">&lt;&lt;</span> v1 <span class="token operator">&lt;&lt;</span> <span class="token string">" and "</span> <span class="token operator">&lt;&lt;</span> v2 <span class="token operator">&lt;&lt;</span> <span class="token string">" is "</span> <span class="token operator">&lt;&lt;</span> v1 <span class="token operator">+</span> v2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>上段代码的第一行 <code>#include</code> 是<strong>预处理指令</strong>，告诉编译器想要使用 <code>iostream</code> 库，尖括号中的名字指出该程序使用了一个标准库头文件(自定义头文件使用双引号)。</li><li>向流写入数据：<ul><li><code>main</code> 函数体中的第一条语句是一个表达式，表达式通常由一个或多个运算对象和一个运算符组成，并且一个表达式必定会产生一个运算结果。该表达式使用了<strong>输出运算符</strong> <code>&lt;&lt;</code> 在标准输出上打印消息。</li><li>输出运算符 <code>&lt;&lt;</code> 接收两个运算对象，左侧的运算对象必须是一个标准输出对象，右侧的运算对象是要打印的值，输出运算符的运算结果是<strong>左侧运算对象</strong>。因此输出运算符可以像第一条语句将输出请求连接起来。</li><li><code>endl</code> 是一个被称为<strong>操纵符</strong>的特殊值，写入其作用是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲区刷新的作用是保证程序所有的输出都真正写入到流中，而不是存储在内存等待写入流。类似的操纵符还有 <code>flush</code> 和 <code>ends</code>, <code>flush</code> 的作用是仅刷新缓冲区，<code>ends</code> 的作用是插入 <code>null</code> 并刷新缓冲区。</li></ul></li><li>从流读取数据：与向流写入数据类似</li><li>输入输出语句中的 <code>std::</code> 指出 <code>cout</code>, <code>cin</code> 和 <code>endl</code> 都是定义在名为 <code>std</code> 的<strong>命名空间</strong>里的，其中 <code>::</code> 为<strong>作用域运算符</strong>。其作用是帮助我们避免使用与库中相同名称所导致的冲突，标准库定义的所有名字都定义在 <code>std</code> 命名空间中。</li><li>对于要输入输出的不同类型的对象，标准库实际上定义了不同版本的输入输出运算符来处理。</li></ol><h2 id="1-3-注释简介"><a href="#1-3-注释简介" class="headerlink" title="1.3 注释简介"></a>1.3 注释简介</h2><p>&emsp;代码中的注释能够帮助代码的读者更好地理解代码，而编译器会忽略掉注释，对程序的行为或者性能不会带来任何的影响。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment">/* * 简单函数 * 读取两个数，并求之积 */</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 提示用户输入两个数</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Please enter two numbers:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n1 <span class="token operator">>></span> n2<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The product of the two numbers is "</span> <span class="token operator">&lt;&lt;</span> n1 <span class="token operator">*</span> n2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出结果</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-控制流"><a href="#1-4-控制流" class="headerlink" title="1.4 控制流"></a>1.4 控制流</h2><p>&emsp;程序的语句不光是可以顺序执行的，程序设计语言提供了多种不同的控制流语句，允许我们写出更为复杂的执行路径。</p><h3 id="1-4-1-while-语句"><a href="#1-4-1-while-语句" class="headerlink" title="1.4.1 while 语句"></a>1.4.1 while 语句</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        sum <span class="token operator">+=</span> start<span class="token punctuation">;</span>        <span class="token operator">++</span>start<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;<code>while</code> 循环的执行过程是交替地检测 <code>condition</code> 条件和执行关联的语句 <code>statement</code>, 直至 <code>condition</code> 为假时停止。<br>&emsp;上端代码中有两个特殊的运算符：</p><ol><li>复合赋值运算符 <code>+=</code><br><code>sum += start</code> 等价于 <code>sum = sum + start</code></li><li>(前缀)递增运算符 <code>++</code><br><code>++start</code> 等价于 <code>start = start + 1</code> 等价于 <code>start += 1</code></li></ol><h3 id="1-4-2-for-语句"><a href="#1-4-2-for-语句" class="headerlink" title="1.4.2 for 语句"></a>1.4.2 for 语句</h3><p>&emsp;观察上面的代码，这种在循环条件中检测变量，在循环体中递增变量的模式使用的非常频繁，因此诞生了第二种循环语句 <code>for</code> 语句来简化这种模式的语句。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;<code>for</code>循环相比 <code>while</code> 循环要更复杂一些，它包括循环头和循环体，循环头控制的是循环的次数，包含初始化语句，循环条件以及一个表达式。在第一次循环开始之前会执行初始化语句，在每次执行完循环体中的语句之后，还会执行循环头中的表达式，一般是循环变量的递增或者递减。值得注意的是该例中的 <code>for</code> 语句在循环头定义了一个 <code>int</code> 型的对象 <code>i</code> , 该对象<strong>只能在循环中使用，在循环结束之后不能使用</strong>。</p><h3 id="1-4-3-读取数量不定的输入数据"><a href="#1-4-3-读取数量不定的输入数据" class="headerlink" title="1.4.3 读取数量不定的输入数据"></a>1.4.3 读取数量不定的输入数据</h3><p>&emsp;可以使用 <code>while</code> 循环和输入运算符实现读取数量不定的输入数据。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> val<span class="token punctuation">)</span>        sum <span class="token operator">+=</span> val<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> sum <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;在前面的学习中得知，输入运算符的结果是左侧的对象，因此，每次循环的条件都是 <code>cin</code> 对象。当我们使用 <code>cin</code> 对象作为条件进行判断时，检测的是<strong>流的状态</strong>。只有当流遇到<strong>文件结束符(EOF)<strong>或者遇到一个</strong>无效的输入</strong>时，流的状态会变为无效，条件判断为假。在Windows系统中, 输入文件结束符的方法是 <code>Ctrl + Z</code>, Mac OS X系统中是 <code>Ctrl + D</code>。</p><h3 id="1-4-4-if-语句"><a href="#1-4-4-if-语句" class="headerlink" title="1.4.4 if 语句"></a>1.4.4 if 语句</h3><p>&emsp;直接通过一个例子来学习 <code>if</code> 语句。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> curVal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cin <span class="token operator">>></span> curVal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cin <span class="token operator">>></span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> curVal<span class="token punctuation">)</span>                <span class="token operator">++</span>cnt<span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">&#123;</span>                cout <span class="token operator">&lt;&lt;</span> curVal <span class="token operator">&lt;&lt;</span> <span class="token string">" occurs "</span> <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> <span class="token string">" times"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                curVal <span class="token operator">=</span> val<span class="token punctuation">;</span>                cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        cout <span class="token operator">&lt;&lt;</span> curVal <span class="token operator">&lt;&lt;</span> <span class="token string">" occurs "</span> <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> <span class="token string">" times"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-代码风格"><a href="#1-5-代码风格" class="headerlink" title="1.5 代码风格"></a>1.5 代码风格</h2><p>&emsp;本人所坚持的代码风格是只有函数界定符进行换行，其他不换行。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
